
-> Coroutines are kotlin construct used for asynchronous programming.
-> The are lightweight and helps switching the threads and thread management efficient and easy for manipulation as per use case.
-> Coroutines are NOT threads. They run on top of threads.
-> Primary difference between coroutine and a traditional thread is that threads are more of OS construct whereas coroutines are more of kotlin compiler construct.

-> If we write Thread.sleep(2000), then the thread will be blocked for entire 2 seconds and no work would be done by this thread. It will remain idle.
-> However, using delay(2000) in coroutines will stop the execution, free the thread, save the state from where it needs to continue execution and then remain suspended for 2 seconds.
-> In this way, instead of making the thread idle for 2 seconds, coroutines freed the thread and let it do some other work and then continued once the delay got over hence using the threads efficiently.

-> Coroutines follow structured concurrency which means that a child coroutine gets terminated the moment its parent is terminated.
-> There is a binding of a coroutine lifecycle to that of its parent. This helps in avoiding leaks and forever running.

-> Coroutines support suspended functions.
-> A suspend function has a special property to pause or leave its execution midpoint.
-> This works by saving the state of this suspend function in a Continuation class and then loading this same state after the processing is done and then continue from the next line.
-> Example:- You are doing some work in coroutine. Now there is an API call. Your method will be stopped in midpoint, its state will be saved and the API operation will be performed. After this operation is done, the method will load the states again from the Deferred class and then continue execution.

-> There are various scopes of coroutines associated that defines the lifecycle of the coroutine like lifecycleScope of activity/fragment, viewModelScope for View Models and GlobalScope for application level.
-> These scopes are tied to the lifecycle aware components and get destroyed the moment the component destroys.

-> Coroutines provide a set of dispatchers as well. They define the underlying thread in which the coroutine is gonna run in.
-> Dispatchers.Main for main thread UI operations, Dispatchers.IO for input output/ API calls, Dispatchers.Default for high performing calculations, Dispatchers.Unconfirmed for tasks which do not come in any of these category.
-> Context and Scopes are different terms wrt coroutines. Context defines the type of dispatchers + any supervisor for exception handling etc whereas scope defines how long this coroutine is gonna live for.

-> launch{} creates a new coroutine in a given scope. It returns a Job. The moment launch{} is called, it creates a coroutine and jumps to the next statement. It does NOT wait for this block to be executed fully.
-> async{} creates a new coroutine in a given scope. It returns a Deferred<T> which means that unlike launch{}, async{} gives the result of the execution of the coroutine. The moment async{} is called, it creates a coroutine and jumps to the next statement. It does NOT wait for this block to be executed fully. To get the value of the execution, use await()
-> withContext(){} is used to switch the context(Dispatcher+Supervisor) of a coroutine to perform operation in a different setting. It does NOT create a new coroutine. The moment it's called, the coroutine is suspended, context is changed and block starts to execute and then finally gives the control back to the caller point after block is completed.
-> runBlocking{} is used when you want to run a coroutine in a non suspended fashion + serially + line by line.
-> synchronised{} is an intrinsic lock and is used to run a block in a thread safe manner where only one thread can access a resource at a time. It is not coroutine friendly as it blocks the underlying thread associated with this coroutine.
-> mutex.withLock{} is a mutual exclusion method and is used to run a block in a thread safe manner where only one thread can access a resource at a time. It is coroutine friendly as it suspends the coroutine and keeps in loop but frees the underlying thread associated with it.

-> If there are multiple children coroutines running and any one of them gives an exception which is not handled, then the parent coroutine is cancelled and accordingly all of its children.
-> Supervisor Job/ SupervisorScope is used to handle exception handling gracefully if there are multiple coroutines involved and one of them throws exception but you don't want the remaining children to be affected.

-> job.cancel() does not stop the coroutine immediately just because you explicitly said to.
-> In order for a coroutine to cancel itself, it must have some checks inside it like isActive or any suspended method like delay()/yeild().
-> These act as a checkpoint for the compiler to decide whether this coroutine should be cancelled or not.

-> We can race the two calls and react to whichever finishes first by using select {} from kotlinx.coroutines.
-> select{} lets you await the first result among multiple suspending calls and cancel the rest.
EG:- suspend fun <T> fetchFirst(
      local: suspend () -> T,
      remote: suspend () -> T
  ): T = coroutineScope {
      select<T> {
          async { local() }.onAwait { value ->
              // Local wins
              value
          }
          async { remote() }.onAwait { value ->
              // Remote wins
              value
          }
      }.also {
          // Remaining coroutines are automatically cancelled when select completes
      }
  }

-> In order to make multiple coroutines wait all at once, we can use awaitAll(job1,async1...) method